#' Remove all artifacts generated by scripts
#'
#' Removes all output files generated by scripts in the pipeline, including
#' intermediate files. This provides a complete clean of generated artifacts.
#' The pipeline can be regenerated by running run() again.
#'
#' @param verbose Logical. If TRUE (default), prints progress messages to console.
#' @return Character vector of file paths that were actually removed
#' @export
#' @examples
#' # Copy sample project to temp directory
#' temp_dir <- tempfile()
#' dir.create(temp_dir)
#' sample_proj <- system.file("extdata", "sample-project", package = "bakepipe")
#' file.copy(sample_proj, temp_dir, recursive = TRUE)
#' 
#' # Change to the sample project directory
#' old_wd <- getwd()
#' setwd(file.path(temp_dir, "sample-project"))
#' 
#' # Run the pipeline first to create output files
#' run(verbose = FALSE)
#' 
#' # Now clean up the generated files
#' removed_files <- clean()
#' print(removed_files)
#' 
#' # Restore working directory and clean up
#' setwd(old_wd)
#' unlink(temp_dir, recursive = TRUE)
clean <- function(verbose = TRUE) {
  # Parse all scripts to get dependencies
  dependencies <- parse()

  # If no scripts found, return empty vector
  if (length(dependencies$scripts) == 0) {
    if (verbose) {
      message("\n[CLEAN] \033[1;36mBakepipe Clean\033[0m")
      message("\033[33m   No output files found to clean\033[0m\n")
    }
    return(character(0))
  }

  # Get all outputs from the top-level outputs list
  all_outputs <- dependencies$outputs

  # Only try to remove files that actually exist
  existing_files <- all_outputs[file.exists(all_outputs)]

  # Print header
  if (verbose) {
    message("\n[CLEAN] \033[1;36mBakepipe Clean\033[0m")
    
    if (length(existing_files) == 0) {
      message("\033[32m[OK] No output files to clean - all clean!\033[0m\n")
      return(character(0))
    }

    message(paste0("\033[33m   Found ", length(existing_files), " output file",
               if(length(existing_files) > 1) "s" else "", " to remove\033[0m\n"))
  } else if (length(existing_files) == 0) {
    return(character(0))
  }

  # Calculate max filename width for alignment
  max_width <- max(nchar(existing_files))

  # Remove the files with progress indicators
  removed_files <- character(0)
  failed_files <- character(0)
  
  for (file_path in existing_files) {
    if (file.remove(file_path)) {
      removed_files <- c(removed_files, file_path)
      if (verbose) {
        message(sprintf("\033[31m[RM]  %s\033[0m", file_path))
      }
    } else {
      failed_files <- c(failed_files, file_path)
      if (verbose) {
        message(sprintf("\033[33m[!]  %-*s \033[2m(failed to remove)\033[0m", max_width, file_path))
      }
    }
  }

  # Print summary
  if (verbose) {
    message("\n\033[1;36m[SUMMARY]\033[0m")
    
    if (length(removed_files) > 0) {
      message(sprintf("\033[32m   Removed %d file%s\033[0m", 
                  length(removed_files),
                  if(length(removed_files) > 1) "s" else ""))
    }
    
    if (length(failed_files) > 0) {
      message(sprintf("\033[33m   Failed to remove %d file%s\033[0m", 
                  length(failed_files),
                  if(length(failed_files) > 1) "s" else ""))
    }
    
    message("")
  }

  removed_files
}